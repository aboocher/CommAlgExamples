restart
loadPackage "Nauty"
R = QQ[a..e]
L = generateGraphs R
listOfIdeals = delete({},L/(i-> i#"edges")/(i-> i/product)/ideal/(i-> i_*))

H = new MutableHashTable from {}

for I in listOfIdeals do (
        H#I = new MutableHashTable from {("ideal", ideal I)} )
    peek H#(first keys H)
    populate = method()
    populate(Function, String, MutableHashTable) :=  (attribute, name, T) -> (
	    (T#name = attribute(T#"ideal"));
	    
	        )
	    
	    for k in keys H do populate(codim, "codim", H#k);
	    
	    for k in keys H do populate(regularity, "regularity", H#k);
	    
	    for k in keys H do populate(i-> length res i , "pdim", H#k);
	    
	    for k in keys H do populate(i-> betti res i, "bettiTable", H#k);
	    
	    for k in keys H do populate(degree , "degree", H#k);
	    
	    
	    netList ((values H)/peek)
	    
	    viewHelp MethodFunctionWithOptions
	    bug = method()
	    
	    bug(Function)
	    
	    
	    a MethodFunction is not a FunctionClosure, but a MethodFunctionWithOptions is.
	    
	    class degree
	    class codim
	    viewHelp MethodFunction
	    toString peek last values H
	    T = last values H    
	    
	        header = toString ((keys T)/(i-> "\""|(toString i)|"\""));
		
		
		toCSV = (T) -> (
		        rest = (values T)/(i-> "\""|(toString i)|"\"")
			    )
			
			toCSV (values H)_5
			bettiTable,new BettiTally from {(0,{0},0) => 1, (1,{2},2) => 6, (2,{3},3) => 9, (3,{4},4) => 5, (4,{5},5) => 1},pdim,4,regularity,2,degree,1,codim,2,ideal,ideal(a*d,b*d,c*d,a*e,b*e,c*e)
			bettiTable,new BettiTally from {(0,{0},0) => 1, (1,{2},2) => 8, (2,{3},3) => 14, (3,{4},4) => 9, (4,{5},5) => 2},pdim,4,regularity,2,degree,2,codim,3,ideal,ideal(a*c,b*c,a*d,b*d,a*e,b*e,c*e,d*e)
			"\""
			